## ðŸ“š Data Structures & Algorithms Playground
Welcome to the Data Structures & Algorithms Playground! This repository is a curated collection of coding problems, meticulously organized to help you master fundamental data structures and algorithms. Whether you're preparing for technical interviews, enhancing your problem-solving skills, or simply exploring the fascinating world of computer science fundamentals, this repository is designed for you.

Each problem is accompanied by a clear description, example test cases, and efficient solutions (primarily in [mention preferred language, e.g., Python/Java/C++]).

## ðŸ“‹ Table of Contents
+ Data Structures

  * Arrays

  * Linked Lists

  * Stacks & Queues

  * Trees

  * Graphs

  * Hash Tables

  * Heaps

+ Algorithms

  * Sorting Algorithms

  * Searching Algorithms

  * Dynamic Programming

  * Greedy Algorithms

  * Backtracking

  * Graph Algorithms

  * Bit Manipulation

  * Recursion & Divide and Conquer
 
### Data Structures
This section focuses on various data structures, which are ways of organizing and storing data efficiently. Understanding these foundational structures is crucial for designing optimal solutions to complex problems.

+ Arrays
  
  Problems involving fixed-size collections of elements, including:

  * Array manipulation (rotation, shifting)

  * Finding elements (min/max, duplicates)

  * Subarray problems

  * Two-pointer techniques

  * Prefix sums

+ Linked Lists

  Problems involving dynamic collections of elements where each element points to the next:

  * Singly, Doubly, and Circular Linked Lists

  * Reversing a list

  * Detecting cycles

  * Merging and splitting lists

  * Pointer manipulation

+ Stacks & Queues

Problems utilizing LIFO (Last-In, First-Out) and FIFO (First-In, First-Out) principles:

  * Parentheses balancing

  * Expression evaluation (infix, postfix)

  * Implementing queues using stacks (and vice-versa)

  * BFS/DFS applications

+ Trees

Problems related to hierarchical data structures:

  * Binary Trees, Binary Search Trees (BSTs)

  * Tree traversals (inorder, preorder, postorder, level order)

  * Tree height, diameter, balancing

  * Lowest Common Ancestor (LCA)

+ Tries

+ Graphs

Problems involving a collection of nodes (vertices) and edges:

  * Adjacency Matrix/List representations

  * Graph traversals (BFS, DFS)

  * Shortest path algorithms (Dijkstra, Bellman-Ford, Floyd-Warshall)

  * Minimum Spanning Trees (Prim's, Kruskal's)

  * Topological sorting

  * Cycle detection

+ Hash Tables

Problems leveraging key-value pairs for efficient data retrieval:

  * Hash maps/dictionaries, hash sets

  * Counting frequencies

  * Finding pairs with a specific sum

  * Checking for duplicates

  * Implementing caches

+ Heaps

Problems utilizing a specialized tree-based data structure that satisfies the heap property:

  * Min-Heaps and Max-Heaps

  * Priority Queues

  * Finding K-th largest/smallest elements

  * Median maintenance

  * Heap sort applications

### Algorithms

This section explores various algorithms, which are step-by-step procedures or formulas for solving problems. These techniques provide the logic for efficient computation.

+ Sorting Algorithms

Problems demonstrating various ways to arrange elements in a specific order:

  * Bubble Sort, Selection Sort, Insertion Sort

  * Merge Sort, Quick Sort (Divide and Conquer)

  * Heap Sort

  * Counting Sort, Radix Sort, Bucket Sort (Non-comparison sorts)

+ Searching Algorithms

Problems focused on finding a specific element within a data structure:

  * Linear Search

  * Binary Search (on sorted arrays/lists)

  * Ternary Search

  * Jump Search, Interpolation Search

+ Dynamic Programming

Problems solved by breaking them down into simpler overlapping subproblems and storing the results:

  * Fibonacci sequence, Factorial

  * Knapsack problem (0/1, unbounded)

  * Longest Common Subsequence (LCS), Longest Increasing Subsequence (LIS)

  * Coin Change problem

  * Grid problems (e.g., unique paths)

+ Greedy Algorithms

Problems where the optimal solution is built by making locally optimal choices at each step:

  * Activity Selection Problem

  * Fractional Knapsack

  * Huffman Coding

  * Change-making problems

+ Backtracking

Problems solved by trying to build a solution incrementally, and abandoning a partial solution if it cannot be completed to a valid solution:

  * N-Queens problem

  * Sudoku Solver

  * Permutations and Combinations

  * Subsets with given sum

+ Graph Algorithms

Advanced algorithms applied to graph structures:

  * Network Flow (Max Flow Min Cut)

  * Bipartite Matching

  * Articulation Points and Bridges

  * Strongly Connected Components (Tarjan's, Kosaraju's)

+ Bit Manipulation

Problems where solutions involve operating on individual bits:

  * Checking even/odd

  * Setting/clearing/toggling bits

  * Counting set bits

  * Power of two

  * XOR applications

+ Recursion & Divide and Conquer

Problems solved by defining a function in terms of itself or by breaking a problem into smaller, similar subproblems:

  * Factorial, Fibonacci

  * Tower of Hanoi

  * Binary Search, Merge Sort, Quick Sort (as mentioned above)

#### License
This project is licensed under the MIT License.

